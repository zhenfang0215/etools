<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>定时器提醒</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000000;
            color: #ffffff;
            height: 100vh;
            width: 100vw;
            overflow: hidden; /* 禁止滚动 */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #timerMessage {
            width: 90vw;
            height: 90vh;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            word-break: break-word;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            /* 初始字体大小，将被 JS 动态调整 */
            font-size: 20vw;
            line-height: 1.3;
            padding: 2vh 2vw;
        }
    </style>
</head>
<body>
    <div id="timerMessage">正在加载提示信息...</div>
    <script>
        // 智能调整字体大小，确保内容刚好填满屏幕
        function fitTextToScreen() {
            const messageEl = document.getElementById('timerMessage');
            const text = messageEl.textContent || '';
            
            // 如果文本为空，不调整
            if (!text.trim()) return;
            
            const containerWidth = messageEl.clientWidth;
            const containerHeight = messageEl.clientHeight;
            
            // 从大字体开始尝试
            let fontSize = Math.min(containerWidth * 0.25, containerHeight * 0.25); // 初始 25% 的容器大小
            let minFontSize = 16; // 最小字体 16px
            let maxFontSize = fontSize;
            
            // 二分查找最佳字体大小
            let iterations = 0;
            const maxIterations = 20; // 最多迭代 20 次
            
            while (maxFontSize - minFontSize > 1 && iterations < maxIterations) {
                fontSize = (minFontSize + maxFontSize) / 2;
                messageEl.style.fontSize = fontSize + 'px';
                
                // 检查是否超出容器
                const isOverflowing = 
                    messageEl.scrollHeight > containerHeight || 
                    messageEl.scrollWidth > containerWidth;
                
                if (isOverflowing) {
                    // 字体太大，减小
                    maxFontSize = fontSize;
                } else {
                    // 字体可以，尝试更大
                    minFontSize = fontSize;
                }
                
                iterations++;
            }
            
            // 使用找到的最佳字体大小（略微减小一点点确保不会溢出）
            messageEl.style.fontSize = (minFontSize * 0.98) + 'px';
            
            // 根据字体大小动态调整行高
            if (minFontSize > 100) {
                messageEl.style.lineHeight = '1.2';
            } else if (minFontSize > 50) {
                messageEl.style.lineHeight = '1.3';
            } else {
                messageEl.style.lineHeight = '1.4';
            }
        }
        
        // 监听内容变化
        const observer = new MutationObserver(() => {
            // 使用 requestAnimationFrame 确保 DOM 已更新
            requestAnimationFrame(() => {
                fitTextToScreen();
            });
        });
        
        observer.observe(document.getElementById('timerMessage'), {
            childList: true,
            characterData: true,
            subtree: true
        });
        
        // 窗口大小变化时重新调整
        window.addEventListener('resize', () => {
            fitTextToScreen();
        });
        
        // 页面加载完成后调整
        window.addEventListener('load', () => {
            fitTextToScreen();
        });
        
        // 立即执行一次
        fitTextToScreen();
    </script>
    <script src="timer-preload.js"></script>
</body>
</html>